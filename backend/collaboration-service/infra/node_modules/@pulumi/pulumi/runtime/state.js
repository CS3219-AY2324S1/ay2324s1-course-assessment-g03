"use strict";
// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_hooks_1 = require("async_hooks");
const config = __importStar(require("./config"));
const nodeEnvKeys = {
    project: "PULUMI_NODEJS_PROJECT",
    stack: "PULUMI_NODEJS_STACK",
    dryRun: "PULUMI_NODEJS_DRY_RUN",
    queryMode: "PULUMI_NODEJS_QUERY_MODE",
    parallel: "PULUMI_NODEJS_PARALLEL",
    monitorAddr: "PULUMI_NODEJS_MONITOR",
    engineAddr: "PULUMI_NODEJS_ENGINE",
    syncDir: "PULUMI_NODEJS_SYNC",
    // this value is not set by the CLI and is controlled via a user set env var unlike the values above
    cacheDynamicProviders: "PULUMI_NODEJS_CACHE_DYNAMIC_PROVIDERS",
    organization: "PULUMI_NODEJS_ORGANIZATION",
};
const pulumiEnvKeys = {
    legacyApply: "PULUMI_ENABLE_LEGACY_APPLY",
};
/** @internal */
exports.asyncLocalStorage = new async_hooks_1.AsyncLocalStorage();
/** @internal */
class LocalStore {
    constructor() {
        this.settings = {
            options: {
                organization: process.env[nodeEnvKeys.organization],
                project: process.env[nodeEnvKeys.project] || "project",
                stack: process.env[nodeEnvKeys.stack] || "stack",
                dryRun: process.env[nodeEnvKeys.dryRun] === "true",
                queryMode: process.env[nodeEnvKeys.queryMode] === "true",
                monitorAddr: process.env[nodeEnvKeys.monitorAddr],
                engineAddr: process.env[nodeEnvKeys.engineAddr],
                syncDir: process.env[nodeEnvKeys.syncDir],
                cacheDynamicProviders: process.env[nodeEnvKeys.cacheDynamicProviders] !== "false",
                legacyApply: process.env[pulumiEnvKeys.legacyApply] === "true",
                maximumProcessListeners: 30,
            },
            rpcDone: Promise.resolve(),
            featureSupport: {},
        };
        this.config = {
            [config.configEnvKey]: process.env[config.configEnvKey] || "",
            [config.configSecretKeysEnvKey]: process.env[config.configSecretKeysEnvKey] || "",
        };
        this.stackResource = undefined;
        /**
         * leakCandidates tracks the list of potential leak candidates.
         */
        this.leakCandidates = new Set();
    }
}
exports.LocalStore = LocalStore;
/** Get the root stack resource for the current stack deployment
 * @internal
 */
function getStackResource() {
    const { stackResource } = exports.getStore();
    return stackResource;
}
exports.getStackResource = getStackResource;
/** @internal */
function setStackResource(newStackResource) {
    const localStore = exports.getStore();
    globalThis.stackResource = newStackResource;
    localStore.stackResource = newStackResource;
}
exports.setStackResource = setStackResource;
/** @internal */
function getLocalStore() {
    return exports.asyncLocalStorage.getStore();
}
exports.getLocalStore = getLocalStore;
getLocalStore.captureReplacement = () => {
    const returnFunc = () => {
        if (global.globalStore === undefined) {
            global.globalStore = new LocalStore();
        }
        return global.globalStore;
    };
    return returnFunc;
};
/** @internal */
exports.getStore = () => {
    const localStore = getLocalStore();
    if (localStore === undefined) {
        if (global.globalStore === undefined) {
            global.globalStore = new LocalStore();
        }
        return global.globalStore;
    }
    return localStore;
};
exports.getStore.captureReplacement = () => {
    const returnFunc = () => {
        if (global.globalStore === undefined) {
            global.globalStore = new LocalStore();
        }
        return global.globalStore;
    };
    return returnFunc;
};
//# sourceMappingURL=state.js.map