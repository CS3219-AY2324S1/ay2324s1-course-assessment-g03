"use strict";
// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const index_1 = require("../../index");
const errors_1 = require("../../errors");
const grpc = __importStar(require("@grpc/grpc-js"));
const rt = "registrationType";
function construct(name, type, urn) {
    throw new Error("unimplemented");
}
describe("runtime", () => {
    describe("registrations", () => {
        describe("register", () => {
            const tests = [
                { name: "wildcard version", version: undefined },
                { name: "version", version: "1.2.3" },
                { name: "alpha version", version: "1.0.0-alpha1" },
            ];
            for (const { name, version } of tests) {
                it(`ignores registration on same ${name}`, () => {
                    const source = new Map();
                    assert.strictEqual(index_1.runtime.register(source, rt, "test", { version, construct }), true);
                    assert.strictEqual(index_1.runtime.register(source, rt, "test", { version, construct }), false);
                });
            }
        });
        describe("getRegistration", () => {
            const source = new Map();
            index_1.runtime.register(source, rt, "test", { version: "1.0.1-alpha1", construct });
            index_1.runtime.register(source, rt, "test", { version: "1.0.2", construct });
            index_1.runtime.register(source, rt, "test", { version: "2.2.0", construct });
            index_1.runtime.register(source, rt, "unrelated", { version: "1.0.3", construct });
            index_1.runtime.register(source, rt, "wild", { version: undefined, construct });
            index_1.runtime.register(source, rt, "unreleased", { version: "1.0.0-alpha1", construct });
            index_1.runtime.register(source, rt, "unreleased", { version: "1.0.0-beta1", construct });
            it("throws on invalid version", () => {
                assert.throws(() => index_1.runtime.getRegistration(source, "test", "invalid"));
            });
            it("unknown not found", () => {
                assert.strictEqual(index_1.runtime.getRegistration(source, "unknown", ""), undefined);
                assert.strictEqual(index_1.runtime.getRegistration(source, "unknown", "0.0.1"), undefined);
            });
            it("different major version not found", () => {
                assert.strictEqual(index_1.runtime.getRegistration(source, "test", "0.0.1"), undefined);
                assert.strictEqual(index_1.runtime.getRegistration(source, "test", "3.0.0"), undefined);
            });
            const tests = [
                { name: "blank returns highest version", key: "test", version: "", expected: "2.2.0" },
                { name: "major version respected 1.0.0", key: "test", version: "1.0.0", expected: "1.0.2" },
                { name: "major version respected 2.0.0", key: "test", version: "2.0.0", expected: "2.2.0" },
                { name: "blank returns wild", key: "wild", version: "", expected: undefined },
                { name: "any returns wild", key: "wild", version: "1.2.3", expected: undefined },
                { name: "unreleased returns beta", key: "unreleased", version: "1.0.0", expected: "1.0.0-beta1" },
            ];
            for (const { name, key, version, expected } of tests) {
                it(name, () => {
                    const module = index_1.runtime.getRegistration(source, key, version);
                    assert.notStrictEqual(module, undefined);
                    assert.strictEqual(module.version, expected);
                });
            }
        });
    });
    describe("resource", () => {
        describe("transferProperties", () => {
            before(() => {
                process.on("unhandledRejection", (reason, p) => {
                    assert.fail(`Unhandled Rejection at: ${p}, reason: ${reason}`);
                });
            });
            after(() => {
                process.removeAllListeners("unhandledRejection");
            });
            it("transferProperties does not throw", () => {
                const resolver = index_1.runtime.transferProperties({}, "wew", {
                    foo: "a",
                    baz: "b",
                });
                const err = new Error();
                err.code = grpc.status.CANCELLED;
                assert.strictEqual(errors_1.isGrpcError(err), true);
                resolver["foo"]("", true, false, [], err);
                resolver["baz"]("", true, false, [], err);
            });
        });
        describe("prepareResource", () => {
            before(() => {
                process.on("unhandledRejection", (reason, p) => {
                    assert.fail(`Unhandled Rejection at: ${p}, reason: ${reason}`);
                });
            });
            after(() => {
                process.removeAllListeners("unhandledRejection");
            });
            it("prepareResource does not throw", () => __awaiter(void 0, void 0, void 0, function* () {
                const resolver = yield index_1.runtime.prepareResource("", {}, undefined, true, false, {}, {}, undefined, undefined);
                const err = new Error();
                err.code = grpc.status.CANCELLED;
                if (resolver.resolveID) {
                    resolver.resolveID("", true, err);
                }
                else {
                    assert.fail("resolver.resolveID is undefined");
                }
                resolver.resolveURN("", err);
            }));
        });
    });
});
//# sourceMappingURL=registrations.spec.js.map